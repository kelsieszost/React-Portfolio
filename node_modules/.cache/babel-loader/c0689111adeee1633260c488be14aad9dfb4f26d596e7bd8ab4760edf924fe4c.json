{"ast":null,"code":"var t = require(\"react\");\nfunction e(t) {\n  return t && \"object\" == typeof t && \"default\" in t ? t : {\n    default: t\n  };\n}\nvar n = e(t);\nfunction r(t) {\n  let e = t.width,\n    n = t.height,\n    r = Math.round(e / 2),\n    o = Math.round(n / 2),\n    s = (e + n) / 2;\n  return {\n    stars: i(r, o, s, e, n, t.count),\n    width: e,\n    height: n,\n    x: r,\n    y: o,\n    z: s\n  };\n}\nfunction i(t, e, n, r, i, o) {\n  let s = [];\n  for (let a = 0; a < o; a++) s.push({\n    x: Math.random() * r * 2 - 2 * t,\n    y: Math.random() * i * 2 - 2 * e,\n    z: Math.round(Math.random() * n),\n    stepX: 0,\n    stepY: 0\n  });\n  return s;\n}\nfunction o(e, n, i) {\n  const o = (null == i ? void 0 : i.current) || r({\n    count: n.count,\n    height: n.height,\n    width: n.width\n  });\n  if (n.count !== o.stars.length) if (o.stars.length < n.count) {\n    const {\n      stars: t\n    } = r({\n      count: n.count - o.stars.length,\n      height: n.height,\n      width: n.width\n    });\n    o.stars = [...o.stars, ...t];\n  } else o.stars.splice(0, o.stars.length - n.count);\n  if (n.width !== o.width || n.height !== o.height) {\n    const {\n      stars: t\n    } = r({\n      count: n.count,\n      height: n.height,\n      width: n.width\n    });\n    o.stars = t, o.width = n.width, o.height = n.height, o.x = Math.round(n.width / 2), o.y = Math.round(n.height / 2), o.z = (n.width + n.height) / 2;\n  }\n  t.useEffect(() => {\n    if (!e.current) return;\n    const t = e.current.getContext(\"2d\");\n    if (!t) return;\n    const r = 1 / o.z,\n      {\n        speed: i,\n        starRatio: s,\n        starSize: a\n      } = n;\n    \"string\" == typeof n.starStyle && (t.strokeStyle = n.starStyle), t.lineCap = n.starShape;\n    const h = 1e3 / n.fps;\n    let u,\n      d,\n      c,\n      l = Date.now();\n    return u = requestAnimationFrame(function e() {\n      t && (u = requestAnimationFrame(e), d = Date.now(), c = d - l, c < h || (l = d - c % h, function (_ref) {\n        let {\n          context: t,\n          stars: e,\n          width: n,\n          height: r,\n          z: i,\n          x: o,\n          y: s,\n          starLineWidthRatio: a,\n          speed: h,\n          starRatio: u,\n          starSize: d,\n          strokeStyle: c,\n          bgStyle: l,\n          clear: g,\n          noBackground: f\n        } = _ref;\n        g && (t.clearRect(0, 0, n, r), f || (t.fillStyle = l, t.fillRect(0, 0, n, r)));\n        let w = !1;\n        for (let l = 0; l < e.length; l++) {\n          \"function\" == typeof c && (t.strokeStyle = c());\n          let g = e[l],\n            f = g.stepX,\n            p = g.stepY;\n          w = !0, g.z -= h, g.z > i && (g.z -= i, w = !1), g.z < 0 && (g.z += i, w = !1), g.stepX = o + g.x / g.z * u, g.stepY = s + g.y / g.z * u, w = w && f > 0 && f < n && p > 0 && p < r, w && (t.beginPath(), t.lineWidth = (1 - a * g.z) * d, t.moveTo(f, p), t.lineTo(g.stepX, g.stepY), t.stroke(), t.closePath());\n        }\n      }({\n        context: t,\n        speed: i,\n        starRatio: s,\n        starSize: a,\n        starLineWidthRatio: r,\n        strokeStyle: n.starStyle,\n        bgStyle: n.bgStyle,\n        noBackground: n.noBackground,\n        clear: n.clear,\n        ...o\n      })));\n    }), () => cancelAnimationFrame(u);\n  }, [n]);\n}\nconst s = _ref2 => {\n  let {\n    width: e = 300,\n    height: i = 300,\n    starStyle: s = \"#fff\",\n    bgStyle: a = \"#000\",\n    count: h = 3e3,\n    speed: u = 3,\n    starRatio: d = 356,\n    starSize: c = 1.4,\n    starShape: l = \"round\",\n    clear: g = !0,\n    noBackground: f = !1,\n    fps: w = 10,\n    ...p\n  } = _ref2;\n  const S = t.useRef(null);\n  return o(S, {\n    width: e,\n    height: i,\n    starStyle: s,\n    bgStyle: a,\n    count: h,\n    fps: w,\n    speed: u,\n    starRatio: d,\n    starShape: l,\n    starSize: c,\n    clear: g,\n    noBackground: f\n  }, t.useRef(r({\n    count: h,\n    height: i,\n    width: e\n  }))), n.default.createElement(\"canvas\", Object.assign({\n    ref: S\n  }, {\n    width: e,\n    height: i\n  }, p));\n};\nfunction a() {\n  let [e, n] = t.useState(h());\n  function r() {\n    n(h());\n  }\n  return t.useEffect(() => (window.addEventListener(\"resize\", r), () => {\n    window.removeEventListener(\"resize\", r);\n  }), []), e;\n}\nfunction h() {\n  return {\n    innerHeight: window.innerHeight,\n    innerWidth: window.innerWidth,\n    outerHeight: window.outerHeight,\n    outerWidth: window.outerWidth\n  };\n}\nconst u = {\n  position: \"fixed\",\n  zIndex: -1\n};\nexports.StarField = s, exports.WindowSizeStarField = _ref3 => {\n  let {\n    style: t,\n    ...e\n  } = _ref3;\n  const {\n    innerWidth: r,\n    innerHeight: i\n  } = a();\n  return n.default.createElement(s, Object.assign({}, e, {\n    style: {\n      ...u,\n      ...t\n    },\n    width: r,\n    height: i\n  }));\n}, exports.randomColor = function () {\n  return `#${Array.apply(null, new Array(6)).map(() => \"0123456789ABCDEF\"[Math.floor(16 * Math.random())]).join(\"\")}`;\n}, exports.useStarField = o, exports.useWindowSize = a;","map":{"version":3,"mappings":"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","names":["createStarsState","options","width","height","x","Math","round","y","z","stars","createStars","count","starPool","i","push","random","stepX","stepY","useStarField","canvasRef","stateReference","initialState","current","length","splice","useEffect","context","getContext","starLineWidthRatio","speed","starRatio","starSize","starStyle","strokeStyle","lineCap","starShape","fpsInterval","fps","animationFrameId","now","elapsed","then","Date","requestAnimationFrame","animateFrame","noBackground","bgStyle","clear","clearRect","fillStyle","fillRect","drawStarStep","star","currentX","currentY","beginPath","lineWidth","moveTo","lineTo","stroke","closePath","drawStarField","cancelAnimationFrame","StarField","restProps","useRef","React","ref","useWindowSize","windowSize","setWindowSize","useState","getWindowSize","handleResize","window","addEventListener","removeEventListener","innerHeight","innerWidth","outerHeight","outerWidth","fixedPositionStyle","position","zIndex","exports","style","Array","apply","map","floor","join"],"sources":["/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/field/StarState.ts","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/hooks/useStarField.ts","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/field/drawStarField.ts","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/components/StarField.tsx","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/hooks/useWindowSize.ts","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/components/WindowSizeStarField.tsx","/Users/kelsieszost/Desktop/React-Portfolio/node_modules/starfield-react/src/color/randomColor.ts"],"sourcesContent":["export interface StarFieldState {\n  width: number\n  height: number\n  x: number\n  y: number\n  z: number\n  stars: StarState[]\n}\n\nexport interface StarState {\n  x: number\n  y: number\n  z: number\n  stepX: number\n  stepY: number\n}\n\nexport type ColorFunction = () => string\n\nexport function createStarsState(options: { width: number, height: number, count: number }): StarFieldState {\n  let width = options.width\n  let height = options.height\n\n  let x = Math.round(width / 2)\n  let y = Math.round(height / 2)\n  let z = (width + height) / 2\n\n  return {\n    stars: createStars(x, y, z, width, height, options.count),\n    width,\n    height,\n    x,\n    y,\n    z,\n  }\n}\n\nexport function createStars(\n  x: number,\n  y: number,\n  z: number,\n  width: number,\n  height: number,\n  count: number,\n) {\n  let starPool: StarState[] = []\n  for (let i = 0; i < count; i++) {\n    starPool.push({\n      x: Math.random() * width * 2 - x * 2,\n      y: Math.random() * height * 2 - y * 2,\n      z: Math.round(Math.random() * z),\n      stepX: 0,\n      stepY: 0,\n    })\n  }\n  return starPool\n}\n","import { MutableRefObject, RefObject, useEffect } from 'react'\n\nimport { ColorFunction, createStarsState, StarFieldState } from '../field/StarState'\nimport { drawStarField } from '../field/drawStarField'\n\nexport interface Options {\n  count: number\n  speed: number\n  starRatio: number\n  starSize: number\n  width: number\n  height: number\n  starStyle: ColorFunction | string\n  clear: boolean\n  starShape: 'butt' | 'round' | 'square'\n  bgStyle: string\n  fps: number\n  noBackground: boolean\n}\n\nexport function useStarField(\n  canvasRef: RefObject<HTMLCanvasElement>,\n  options: Options,\n  stateReference?: MutableRefObject<StarFieldState>,\n) {\n  const initialState = stateReference?.current || createStarsState({\n    count: options.count,\n    height: options.height,\n    width: options.width,\n  })\n\n  if (options.count !== initialState.stars.length) {\n    if (initialState.stars.length < options.count) {\n      const { stars } = createStarsState({\n        count: options.count - initialState.stars.length,\n        height: options.height,\n        width: options.width,\n      })\n      initialState.stars = [...initialState.stars, ...stars]\n    } else {\n      initialState.stars.splice(0, initialState.stars.length - options.count)\n    }\n  }\n\n  if (options.width !== initialState.width || options.height !== initialState.height) {\n    const { stars } = createStarsState({\n      count: options.count,\n      height: options.height,\n      width: options.width,\n    })\n    initialState.stars = stars\n    initialState.width = options.width\n    initialState.height = options.height\n    initialState.x = Math.round(options.width / 2)\n    initialState.y = Math.round(options.height / 2)\n    initialState.z = (options.width + options.height) / 2\n  }\n\n  useEffect(() => {\n    if (!canvasRef.current) return\n    const context = canvasRef.current.getContext('2d')\n    if (!context) return\n\n    const starLineWidthRatio = 1 / initialState.z\n    const { speed, starRatio, starSize } = options\n\n    if (typeof options.starStyle === 'string') {\n      context.strokeStyle = options.starStyle\n    }\n\n    context.lineCap = options.starShape\n\n    const fpsInterval = 1000 / options.fps\n    let animationFrameId: number\n    let then = Date.now()\n    let now, elapsed\n\n    animationFrameId = requestAnimationFrame(animateFrame)\n\n    function animateFrame() {\n      if (!context) return\n\n      animationFrameId = requestAnimationFrame(animateFrame)\n\n      now = Date.now()\n      elapsed = now - then\n      if (elapsed < fpsInterval) return\n      then = now - (elapsed % fpsInterval)\n\n      drawStarField({\n        context,\n        speed,\n        starRatio,\n        starSize,\n        starLineWidthRatio,\n        strokeStyle: options.starStyle,\n        bgStyle: options.bgStyle,\n        noBackground: options.noBackground,\n        clear: options.clear,\n        ...initialState,\n      })\n    }\n\n    return () => cancelAnimationFrame(animationFrameId)\n  }, [options])\n}\n","import { ColorFunction, StarState } from './StarState'\n\nexport type DrawState = {\n  context: CanvasRenderingContext2D\n  stars: StarState[]\n  width: number\n  height: number\n  z: number\n  x: number\n  y: number\n  starLineWidthRatio: number\n  speed: number\n  starRatio: number\n  starSize: number\n  strokeStyle: ColorFunction | string\n  bgStyle: string\n  clear: boolean\n  noBackground: boolean\n}\n\nexport function drawStarField({\n  context,\n  stars,\n  width,\n  height,\n  z,\n  x,\n  y,\n  starLineWidthRatio,\n  speed,\n  starRatio,\n  starSize,\n  strokeStyle,\n  bgStyle,\n  clear,\n  noBackground,\n}: DrawState) {\n  if (clear) {\n    context.clearRect(0, 0, width, height)\n\n    if (!noBackground) {\n      context.fillStyle = bgStyle\n      context.fillRect(0, 0, width, height)\n    }\n  }\n\n  let drawStarStep = false\n\n  for (let i = 0; i < stars.length; i++) {\n    if (typeof strokeStyle === 'function') {\n      context.strokeStyle = strokeStyle()\n    }\n\n    let star = stars[i]\n    let currentX = star.stepX\n    let currentY = star.stepY\n\n    drawStarStep = true\n    star.z -= speed\n\n    if (star.z > z) {\n      star.z -= z\n      drawStarStep = false\n    }\n\n    if (star.z < 0) {\n      star.z += z\n      drawStarStep = false\n    }\n\n    star.stepX = x + (star.x / star.z) * starRatio\n    star.stepY = y + (star.y / star.z) * starRatio\n\n    drawStarStep = drawStarStep &&\n      currentX > 0 && currentX < width &&\n      currentY > 0 && currentY < height\n\n    if (drawStarStep) {\n      context.beginPath()\n      context.lineWidth = (1 - starLineWidthRatio * star.z) * starSize\n      context.moveTo(currentX, currentY)\n      context.lineTo(star.stepX, star.stepY)\n      context.stroke()\n      context.closePath()\n    }\n  }\n}\n","import React, { FC, useRef, CSSProperties } from 'react'\n\nimport { useStarField } from '../hooks/useStarField'\nimport { createStarsState, StarFieldState } from '../field/StarState'\n\nexport type StarFieldProps = {\n  // Width is passed through to the html canvas element\n  width?: number\n  // Height is passed through to the html canvas element\n  height?: number\n  // To total number of stars created for the animation\n  count?: number\n  // The speed of travel through the Star Field\n  speed?: number\n  // The frames per second of the animation draw calls\n  fps?: number\n  // Clear the canvas on each draw call,\n  // when false each draw call remains on the canvas and overlapped by the next\n  clear?: boolean\n  // The ratio used to determine the size of the entire Star Field\n  starRatio?: number\n  // The size of the stroke used for drawing each star\n  starSize?: number\n  // The canvas [strokeStyle](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/strokeStyle)\n  // used for drawing each star\n  // Also valid, a function that returns the strokeStyle from being invoked,\n  // each draw call for special effects like random color\n  starStyle?: ColorFunction | string\n  // The canvas [lineCap](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineCap)\n  // used for drawing each star\n  starShape?: 'butt' | 'round' | 'square'\n  // The canvas [fillStyle](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle)\n  // used for drawing the background of the canvas\n  bgStyle?: string\n  // A flag to set no background of fillStyle of the canvas\n  noBackground?: boolean\n  className?: string\n  style?: CSSProperties\n}\n\ntype ColorFunction = () => string\n\nexport const StarField: FC<StarFieldProps> = ({\n  width = 300,\n  height = 300,\n  starStyle = '#fff',\n  bgStyle = '#000',\n  count = 3000,\n  speed = 3,\n  starRatio = 356,\n  starSize = 1.4,\n  starShape = 'round',\n  clear = true,\n  noBackground = false,\n  fps = 10,\n  ...restProps\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const stateRef = useRef<StarFieldState>(createStarsState({\n    count,\n    height,\n    width,\n  }))\n\n  useStarField(canvasRef, {\n    width,\n    height,\n    starStyle,\n    bgStyle,\n    count,\n    fps,\n    speed,\n    starRatio,\n    starShape,\n    starSize,\n    clear,\n    noBackground,\n  }, stateRef)\n\n  return <canvas\n    ref={canvasRef}\n    {...{ width, height }}\n    {...restProps}\n  />\n}\n","import { useEffect, useState } from 'react'\n\nexport interface WindowSize {\n  innerHeight: number\n  innerWidth: number\n  outerHeight: number\n  outerWidth: number\n}\n\nexport function useWindowSize(): WindowSize {\n  let [windowSize, setWindowSize] = useState(getWindowSize())\n\n  function handleResize() {\n    setWindowSize(getWindowSize())\n  }\n\n  useEffect(() => {\n    window.addEventListener('resize', handleResize)\n\n    return () => {\n      window.removeEventListener('resize', handleResize)\n    }\n  }, [])\n\n  return windowSize\n}\n\nfunction getWindowSize(): WindowSize {\n  return {\n    innerHeight: window.innerHeight,\n    innerWidth: window.innerWidth,\n    outerHeight: window.outerHeight,\n    outerWidth: window.outerWidth,\n  }\n}\n","import React, { CSSProperties, FC } from 'react'\n\nimport { useWindowSize } from '../hooks/useWindowSize'\nimport { StarField, StarFieldProps } from './StarField'\n\nconst fixedPositionStyle: CSSProperties = {\n  position: 'fixed',\n  zIndex: -1,\n}\n\nexport const WindowSizeStarField: FC<StarFieldProps> = ({ style, ...restProps }) => {\n  const { innerWidth, innerHeight } = useWindowSize()\n\n  return <StarField\n    {...restProps}\n    style={{ ...fixedPositionStyle, ...style }}\n    width={innerWidth}\n    height={innerHeight}\n  />\n}\n","const SEED_CHARS = '0123456789ABCDEF'\n\nexport function randomColor(): string {\n  const color = Array\n    .apply(null, new Array(6))\n    .map(() => SEED_CHARS[Math.floor(Math.random() * 16)])\n    .join('')\n\n  return `#${color}`\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}